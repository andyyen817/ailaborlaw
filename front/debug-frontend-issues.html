<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰ç«¯é—®é¢˜è°ƒè¯•å·¥å…·</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section { border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin: 20px 0; }
        .result { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin: 10px 0; font-family: monospace; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
        .button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        .button:hover { background: #0056b3; }
        .success { color: #28a745; } .error { color: #dc3545; } .warning { color: #ffc107; }
    </style>
</head>
<body>
    <h1>ğŸ” å‰ç«¯é—®é¢˜è°ƒè¯•å·¥å…·</h1>
    
    <div class="section">
        <h2>æ­¥éª¤1: åŸºç¡€ç¯å¢ƒæ£€æŸ¥</h2>
        <button class="button" onclick="checkEnvironment()">æ£€æŸ¥åŸºç¡€ç¯å¢ƒ</button>
        <div id="envResult" class="result"></div>
    </div>

    <div class="section">
        <h2>æ­¥éª¤2: è®¤è¯çŠ¶æ€æ£€æŸ¥</h2>
        <button class="button" onclick="checkAuthState()">æ£€æŸ¥è®¤è¯çŠ¶æ€</button>
        <div id="authResult" class="result"></div>
    </div>

    <div class="section">
        <h2>æ­¥éª¤3: APIè°ƒç”¨æµ‹è¯•</h2>
        <button class="button" onclick="testDirectAPI()">æµ‹è¯•ç›´æ¥APIè°ƒç”¨</button>
        <div id="apiResult" class="result"></div>
    </div>

    <div class="section">
        <h2>æ­¥éª¤4: Vueåº”ç”¨çŠ¶æ€æ£€æŸ¥</h2>
        <button class="button" onclick="checkVueApp()">æ£€æŸ¥Vueåº”ç”¨çŠ¶æ€</button>
        <div id="vueResult" class="result"></div>
    </div>

    <div class="section">
        <h2>æ­¥éª¤5: æ¨¡æ‹Ÿå‰ç«¯é€»è¾‘</h2>
        <button class="button" onclick="simulateFrontendLogic()">æ¨¡æ‹Ÿå‰ç«¯é€»è¾‘</button>
        <div id="simulateResult" class="result"></div>
    </div>

    <script>
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'ğŸ“';
            return `[${timestamp}] ${prefix} ${message}`;
        }

        function checkEnvironment() {
            const resultEl = document.getElementById('envResult');
            let result = '';

            try {
                // æ£€æŸ¥åŸºç¡€ç¯å¢ƒ
                result += log('=== åŸºç¡€ç¯å¢ƒæ£€æŸ¥ ===') + '\n';
                result += log(`å½“å‰é¡µé¢URL: ${window.location.href}`) + '\n';
                result += log(`User Agent: ${navigator.userAgent}`) + '\n';
                
                // æ£€æŸ¥localStorage
                result += log(`LocalStorageå¯ç”¨: ${typeof Storage !== 'undefined'}`) + '\n';
                
                // æ£€æŸ¥å…³é”®çš„localStorageé¡¹ç›®
                const authToken = localStorage.getItem('auth_token');
                const authUser = localStorage.getItem('auth_user');
                const authUserId = localStorage.getItem('auth_user_id');
                
                result += log(`auth_tokenå­˜åœ¨: ${!!authToken}`) + '\n';
                if (authToken) {
                    result += log(`Tokené•¿åº¦: ${authToken.length}`) + '\n';
                    result += log(`Tokenå‰ç¼€: ${authToken.substring(0, 20)}...`) + '\n';
                }
                
                result += log(`auth_userå­˜åœ¨: ${!!authUser}`) + '\n';
                if (authUser) {
                    try {
                        const userData = JSON.parse(authUser);
                        result += log(`ç”¨æˆ·æ•°æ®: ${JSON.stringify(userData, null, 2)}`) + '\n';
                    } catch (e) {
                        result += log(`ç”¨æˆ·æ•°æ®è§£æé”™è¯¯: ${e.message}`, 'error') + '\n';
                    }
                }
                
                result += log(`auth_user_idå­˜åœ¨: ${!!authUserId}`) + '\n';
                if (authUserId) {
                    result += log(`ç”¨æˆ·ID: ${authUserId}`) + '\n';
                }

                // æ£€æŸ¥Vueåº”ç”¨
                const app = document.querySelector('#app');
                result += log(`Vueåº”ç”¨å®¹å™¨å­˜åœ¨: ${!!app}`) + '\n';
                
                result += log('åŸºç¡€ç¯å¢ƒæ£€æŸ¥å®Œæˆ', 'success') + '\n';

            } catch (error) {
                result += log(`ç¯å¢ƒæ£€æŸ¥å‡ºé”™: ${error.message}`, 'error') + '\n';
            }

            resultEl.textContent = result;
        }

        function checkAuthState() {
            const resultEl = document.getElementById('authResult');
            let result = '';

            try {
                result += log('=== è®¤è¯çŠ¶æ€æ£€æŸ¥ ===') + '\n';

                // 1. æ¨¡æ‹Ÿ authService.getToken()
                const token = localStorage.getItem('auth_token');
                result += log(`æ¨¡æ‹Ÿ authService.getToken(): ${token ? 'æœ‰Token' : 'æ— Token'}`) + '\n';

                // 2. æ¨¡æ‹Ÿ authService.isAuthenticated() é€»è¾‘
                if (token) {
                    // æ£€æŸ¥tokenæ˜¯å¦è¿‡æœŸ
                    const tokenExpires = localStorage.getItem('auth_token_expires');
                    result += log(`Tokenè¿‡æœŸæ—¶é—´: ${tokenExpires}`) + '\n';
                    
                    if (tokenExpires) {
                        const expiresAt = parseInt(tokenExpires);
                        const now = Date.now();
                        const isExpired = now >= expiresAt;
                        
                        result += log(`å½“å‰æ—¶é—´: ${now}`) + '\n';
                        result += log(`è¿‡æœŸæ—¶é—´: ${expiresAt}`) + '\n';
                        result += log(`Tokenå·²è¿‡æœŸ: ${isExpired}`) + '\n';
                        result += log(`æ¨¡æ‹Ÿ authService.isAuthenticated(): ${!isExpired}`) + '\n';
                    } else {
                        // æ²¡æœ‰è¿‡æœŸæ—¶é—´ä¿¡æ¯ï¼Œå°è¯•è§£æJWT
                        try {
                            const payload = parseJwt(token);
                            if (payload && payload.exp) {
                                const expiresAt = payload.exp * 1000;
                                const now = Date.now();
                                const isExpired = now >= expiresAt;
                                
                                result += log(`ä»JWTè§£æè¿‡æœŸæ—¶é—´: ${expiresAt}`) + '\n';
                                result += log(`å½“å‰æ—¶é—´: ${now}`) + '\n';
                                result += log(`Tokenå·²è¿‡æœŸ: ${isExpired}`) + '\n';
                                result += log(`æ¨¡æ‹Ÿ authService.isAuthenticated(): ${!isExpired}`) + '\n';
                            } else {
                                result += log(`æ— æ³•ä»JWTè·å–è¿‡æœŸä¿¡æ¯`, 'warning') + '\n';
                                result += log(`æ¨¡æ‹Ÿ authService.isAuthenticated(): true (å‡è®¾æœ‰æ•ˆ)`) + '\n';
                            }
                        } catch (e) {
                            result += log(`JWTè§£æå¤±è´¥: ${e.message}`, 'error') + '\n';
                            result += log(`æ¨¡æ‹Ÿ authService.isAuthenticated(): false`) + '\n';
                        }
                    }
                } else {
                    result += log(`æ¨¡æ‹Ÿ authService.isAuthenticated(): false (æ— Token)`) + '\n';
                }

                result += log('è®¤è¯çŠ¶æ€æ£€æŸ¥å®Œæˆ', 'success') + '\n';

            } catch (error) {
                result += log(`è®¤è¯çŠ¶æ€æ£€æŸ¥å‡ºé”™: ${error.message}`, 'error') + '\n';
            }

            resultEl.textContent = result;
        }

        function parseJwt(token) {
            if (!token) return null;
            
            try {
                if (!token.includes('.') || token.split('.').length !== 3) {
                    return null;
                }
                
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(
                    window.atob(base64)
                        .split('')
                        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                        .join('')
                );
                
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error('JWTè§£æå¤±è´¥:', e);
                return null;
            }
        }

        async function testDirectAPI() {
            const resultEl = document.getElementById('apiResult');
            let result = '';

            try {
                result += log('=== ç›´æ¥APIè°ƒç”¨æµ‹è¯• ===') + '\n';

                const token = localStorage.getItem('auth_token');
                if (!token) {
                    result += log('æ— è®¤è¯Tokenï¼Œæ— æ³•è¿›è¡ŒAPIæµ‹è¯•', 'error') + '\n';
                    resultEl.textContent = result;
                    return;
                }

                result += log('æ­£åœ¨æµ‹è¯• /api/v1/chat/sessions API...') + '\n';

                // æ¨¡æ‹Ÿå‰ç«¯çš„APIè°ƒç”¨
                const response = await fetch('/api/v1/chat/sessions', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                result += log(`APIå“åº”çŠ¶æ€: ${response.status}`) + '\n';
                result += log(`APIå“åº”çŠ¶æ€æ–‡æœ¬: ${response.statusText}`) + '\n';

                if (response.ok) {
                    const data = await response.json();
                    result += log(`APIå“åº”æˆåŠŸ`) + '\n';
                    result += log(`å“åº”æ•°æ®: ${JSON.stringify(data, null, 2)}`) + '\n';
                    
                    if (data.success && data.data && data.data.sessions) {
                        result += log(`æ‰¾åˆ° ${data.data.sessions.length} ä¸ªä¼šè¯`, 'success') + '\n';
                    } else {
                        result += log(`å“åº”æ ¼å¼å¼‚å¸¸`, 'warning') + '\n';
                    }
                } else {
                    const errorData = await response.json().catch(() => null);
                    result += log(`APIè°ƒç”¨å¤±è´¥`, 'error') + '\n';
                    if (errorData) {
                        result += log(`é”™è¯¯è¯¦æƒ…: ${JSON.stringify(errorData, null, 2)}`, 'error') + '\n';
                    }
                }

            } catch (error) {
                result += log(`APIæµ‹è¯•å‡ºé”™: ${error.message}`, 'error') + '\n';
                result += log(`é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'error') + '\n';
            }

            resultEl.textContent = result;
        }

        function checkVueApp() {
            const resultEl = document.getElementById('vueResult');
            let result = '';

            try {
                result += log('=== Vueåº”ç”¨çŠ¶æ€æ£€æŸ¥ ===') + '\n';

                // æ£€æŸ¥Vueåº”ç”¨å®¹å™¨
                const appContainer = document.querySelector('#app');
                result += log(`Vueåº”ç”¨å®¹å™¨å­˜åœ¨: ${!!appContainer}`) + '\n';

                if (appContainer) {
                    // æ£€æŸ¥Vueå®ä¾‹
                    const vueInstance = appContainer.__vue_app__;
                    result += log(`Vueåº”ç”¨å®ä¾‹å­˜åœ¨: ${!!vueInstance}`) + '\n';

                    // æ£€æŸ¥Vueç‰ˆæœ¬
                    if (window.Vue) {
                        result += log(`Vueç‰ˆæœ¬: ${window.Vue.version || 'unknown'}`) + '\n';
                    }

                    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•Vueç›¸å…³çš„å…¨å±€å˜é‡
                    const vueGlobals = Object.keys(window).filter(key => key.toLowerCase().includes('vue'));
                    result += log(`Vueç›¸å…³å…¨å±€å˜é‡: ${vueGlobals.join(', ') || 'æ— '}`) + '\n';
                }

                // æ£€æŸ¥å½“å‰é¡µé¢æ˜¯å¦æ˜¯å‰ç«¯åº”ç”¨é¡µé¢
                const isVitePage = document.querySelector('script[src*="/@vite/client"]');
                result += log(`Viteå¼€å‘é¡µé¢: ${!!isVitePage}`) + '\n';

                // æ£€æŸ¥æ˜¯å¦æœ‰è·¯ç”±ç›¸å…³ä¿¡æ¯
                result += log(`å½“å‰è·¯å¾„: ${window.location.pathname}`) + '\n';
                result += log(`å½“å‰æŸ¥è¯¢å‚æ•°: ${window.location.search}`) + '\n';

                result += log('Vueåº”ç”¨çŠ¶æ€æ£€æŸ¥å®Œæˆ', 'success') + '\n';

            } catch (error) {
                result += log(`Vueåº”ç”¨æ£€æŸ¥å‡ºé”™: ${error.message}`, 'error') + '\n';
            }

            resultEl.textContent = result;
        }

        async function simulateFrontendLogic() {
            const resultEl = document.getElementById('simulateResult');
            let result = '';

            try {
                result += log('=== æ¨¡æ‹Ÿå‰ç«¯é€»è¾‘ ===') + '\n';

                // 1. æ¨¡æ‹ŸauthService.getToken()æ£€æŸ¥
                const token = localStorage.getItem('auth_token');
                result += log(`æ­¥éª¤1: è·å–Token - ${token ? 'æˆåŠŸ' : 'å¤±è´¥'}`) + '\n';

                if (!token) {
                    result += log(`å‰ç«¯é€»è¾‘ä¼šåœ¨æ­¤å¤„å¤±è´¥ï¼šthrow new Error('éœ€è¦ç”¨æˆ·è®¤è¯')`, 'error') + '\n';
                    resultEl.textContent = result;
                    return;
                }

                // 2. æ¨¡æ‹Ÿè®¤è¯æ£€æŸ¥
                let isAuthenticated = true;
                const tokenExpires = localStorage.getItem('auth_token_expires');
                if (tokenExpires) {
                    const isExpired = Date.now() >= parseInt(tokenExpires);
                    isAuthenticated = !isExpired;
                } else {
                    // å°è¯•ä»JWTè§£æ
                    try {
                        const payload = parseJwt(token);
                        if (payload && payload.exp) {
                            const isExpired = Date.now() >= (payload.exp * 1000);
                            isAuthenticated = !isExpired;
                        }
                    } catch (e) {
                        result += log(`JWTè§£æå¤±è´¥ï¼Œå‡è®¾è®¤è¯æœ‰æ•ˆ`, 'warning') + '\n';
                    }
                }

                result += log(`æ­¥éª¤2: è®¤è¯æ£€æŸ¥ - ${isAuthenticated ? 'é€šè¿‡' : 'å¤±è´¥'}`) + '\n';

                if (!isAuthenticated) {
                    result += log(`å‰ç«¯é€»è¾‘ä¼šåœ¨æ­¤å¤„å¤±è´¥ï¼šè®¤è¯å·²è¿‡æœŸ`, 'error') + '\n';
                    resultEl.textContent = result;
                    return;
                }

                // 3. æ¨¡æ‹ŸAPIè°ƒç”¨
                result += log(`æ­¥éª¤3: å‡†å¤‡APIè°ƒç”¨`) + '\n';
                result += log(`è¯·æ±‚URL: /api/v1/chat/sessions`) + '\n';
                result += log(`è¯·æ±‚æ–¹æ³•: GET`) + '\n';
                result += log(`è®¤è¯å¤´: Bearer ${token.substring(0, 20)}...`) + '\n';

                try {
                    const response = await fetch('/api/v1/chat/sessions', {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    result += log(`æ­¥éª¤4: APIå“åº” - çŠ¶æ€ç  ${response.status}`) + '\n';

                    if (response.ok) {
                        const data = await response.json();
                        result += log(`æ­¥éª¤5: æ•°æ®è§£æ - æˆåŠŸ`) + '\n';

                        // æ¨¡æ‹Ÿå‰ç«¯æ•°æ®å¤„ç†é€»è¾‘
                        if (data && data.success && data.data && data.data.sessions && data.data.sessions.length > 0) {
                            result += log(`æ­¥éª¤6: æ•°æ®å¤„ç† - æ‰¾åˆ° ${data.data.sessions.length} ä¸ªä¼šè¯`, 'success') + '\n';
                            
                            // æ¨¡æ‹Ÿæ•°æ®æ ¼å¼åŒ–
                            const formattedSessions = data.data.sessions.map(session => ({
                                id: session.sessionId,
                                title: session.title || 'æ–°çš„å°è©±',
                                date: session.lastMessageAt || session.createdAt,
                                status: session.status === 'active' ? 'completed' : 'completed'
                            }));
                            
                            result += log(`æ­¥éª¤7: æ•°æ®æ ¼å¼åŒ–å®Œæˆ - ${formattedSessions.length} ä¸ªæ ¼å¼åŒ–ä¼šè¯`, 'success') + '\n';
                            result += log(`å‰ç«¯é€»è¾‘æ‰§è¡ŒæˆåŠŸï¼é—®é¢˜ä¸åœ¨è¿™é‡Œã€‚`, 'success') + '\n';
                        } else {
                            result += log(`æ­¥éª¤6: æ•°æ®å¤„ç† - å“åº”æ ¼å¼å¼‚å¸¸`, 'warning') + '\n';
                            result += log(`å‰ç«¯é€»è¾‘ä¼šæ˜¾ç¤º"æ²¡æœ‰æ‰¾åˆ°ä¼šè¯è®°å½•"`) + '\n';
                        }
                    } else {
                        const errorData = await response.json().catch(() => null);
                        result += log(`æ­¥éª¤5: APIè°ƒç”¨å¤±è´¥`, 'error') + '\n';
                        if (errorData) {
                            result += log(`é”™è¯¯ä¿¡æ¯: ${JSON.stringify(errorData)}`, 'error') + '\n';
                        }
                        result += log(`å‰ç«¯é€»è¾‘ä¼šåœ¨æ­¤å¤„å¤±è´¥`, 'error') + '\n';
                    }

                } catch (apiError) {
                    result += log(`æ­¥éª¤4: APIè°ƒç”¨å¼‚å¸¸ - ${apiError.message}`, 'error') + '\n';
                    result += log(`å‰ç«¯é€»è¾‘ä¼šæ˜¾ç¤ºè¿æ¥é”™è¯¯`, 'error') + '\n';
                }

            } catch (error) {
                result += log(`æ¨¡æ‹Ÿå‰ç«¯é€»è¾‘å‡ºé”™: ${error.message}`, 'error') + '\n';
            }

            resultEl.textContent = result;
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿›è¡ŒåŸºç¡€æ£€æŸ¥
        window.addEventListener('load', function() {
            setTimeout(() => {
                checkEnvironment();
            }, 1000);
        });
    </script>
</body>
</html> 